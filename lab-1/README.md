Наданий код демонструє дотримання кількох принципів програмування:

Принцип єдиної відповідальності (SRP): кожен клас у кодексі має єдину відповідальність. Наприклад, класи Animal, Enclosure, Food і ZooKeeper інкапсулюють конкретні сутності в зоопарку, кожна з яких відповідає за керування власними даними та поведінкою. Це сприяє ремонтопридатності та модульності (код, код).
Принцип відкритості/закритості (OCP): код відкритий для розширення, але закритий для модифікації. Це очевидно в класі Inventory, куди можна додавати нові сутності, не змінюючи існуючий код. Це досягається шляхом передачі списку сутностей до конструктора інвентаризації, що забезпечує гнучкість типів сутностей, які зберігаються в інвентарі (коді).
Принцип заміни Ліскова (LSP): клас Inventory приймає список об’єктів ZooEntity. Це означає, що будь-який підклас ZooEntity, такий як Animal, Enclosure, Food або ZooKeeper, може бути переданий до Inventory, виконуючи LSP. Підкласи можуть бути замінені своїм базовим класом без шкоди для коректності програми (коду).
Принцип інверсії залежностей (DIP): клас Inventory залежить від абстракцій (ZooEntity), а не від конкретних реалізацій. Це дозволяє відокремити модулі вищого рівня (Інвентар) і модулі нижчого рівня (Тварини, Корпуси, Їжа, ZooKeeper), сприяючи гнучкості та полегшенню обслуговування (код).
Принцип відокремлення інтерфейсу (ISP): Інтерфейси (ZooEntity та KeeperEntity) відокремлюються, щоб гарантувати, що реалізовані класи повинні забезпечувати реалізацію лише тих методів, які їм потрібні. Це запобігає змушенню класів реалізовувати методи, які вони не використовують, зменшуючи непотрібні залежності (код, код).
Дотримуючись цих принципів, кодова база стає більш зручною, гнучкою та надійною, причому кожен клас має чітку мету та дотримується встановлених принципів проектування.






a. DRY: код уникає повторень, визначаючи загальну поведінку в методі display_info інтерфейсів ZooEntity та KeeperEntity. Потім цей метод реалізується конкретними класами (Animal, Enclosure, Food, ZooKeeper) для відображення інформації, специфічної для кожної сутності, усуваючи необхідність дублювати логіку відображення (код, код).

b. KISS (Keep It Simple, Stupid): код зберігає простоту, використовуючи прості визначення класів і методи. Кожен клас має чітку мету, а методи лаконічні та цілеспрямовані. Наприклад, клас Inventory несе єдину відповідальність за керування набором сутностей і відображення їхньої інформації (коду).

в. Принципи SOLID:

Принцип єдиної відповідальності (SRP): Кожен клас має єдину відповідальність, наприклад, керування сутністю або відображення інформації. Наприклад, кожен з класів Animal, Enclosure, Food і ZooKeeper обробляє певні сутності (код).
Принцип відкритості/закритості (OCP): клас Inventory відкритий для розширення (можна додавати нові сутності), але закритий для модифікації. Це досягається шляхом прийняття списку сутностей у його конструктор (код).
Принцип заміни Ліскова (LSP): клас Inventory приймає будь-який підклас ZooEntity, дозволяючи заміну, не впливаючи на поведінку класу (коду) Inventory.
Принцип інверсії залежностей (DIP): клас Inventory залежить від абстракцій (ZooEntity), а не від конкретних реалізацій, сприяючи гнучкості та відокремленню (код).
Принцип відокремлення інтерфейсу (ISP): інтерфейси (ZooEntity та KeeperEntity) відокремлюються, щоб гарантувати, що реалізовані класи забезпечують реалізацію лише необхідних методів, запобігаючи непотрібним залежностям (код, код).
d. YAGNI: код не містить непотрібної складності чи функцій. Кожен клас і метод служать чіткій меті, і немає сторонніх компонентів, доданих заздалегідь.
д. Композиція через успадкування: хоча в наданому коді немає явної демонстрації композиції через успадкування, структура допускає це. Наприклад, можна створити клас Zoo, який містить екземпляри Animal, Enclosure, Food і ZooKeeper, а не створювати їх підкласи. Такий підхід сприяв би гнучкості та уникав обмежень успадкування.

f. Програма для інтерфейсів, а не реалізацій: клас Inventory приймає список об’єктів ZooEntity, дотримуючись цього принципу шляхом програмування для інтерфейсу (ZooEntity), а не для конкретних реалізацій. Це забезпечує гнучкість і легшу заміну різних типів сутностей (коду).

g. Швидкий збій: хоча це явно не реалізовано у наданому коді, можна додати обробку помилок і перевірку, щоб гарантувати, що збої виявляються та повідомляються якнайшвидше, підвищуючи надійність системи.
